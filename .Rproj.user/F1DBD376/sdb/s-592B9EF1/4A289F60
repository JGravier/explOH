{
    "collab_server" : "",
    "contents" : "################################\n# Shiny app pour afficher les objets selon le temps avec leaflet\n# avril 2017\n# Server pour explOH_5\n################################\n\n#####\nlibrary(shiny)\n\n\nshinyServer(function(input, output, session) {\n  \n  #1. carte de base\n  output$map <- renderLeaflet({\n    leaflet() %>%\n      setView(lat=47.394211, lng=0.687247, zoom = 15) %>%\n\n      ##tiles\n      addProviderTiles(\"CartoDB.Positron\", group=\"clair\") %>%\n      addProviderTiles(\"CartoDB.DarkMatter\", group=\"sombre\") %>%\n      addProviderTiles(\"Esri.WorldImagery\", group = \"satellite\") %>%\n\n      ##layer control\n      addLayersControl(\n        baseGroups = c(\"clair\",\"sombre\",\"satellite\"),\n        overlayGroups = c(\"géometries\", \"ensembles urbains\", \"traits de rive\"),\n        options=layersControlOptions(autoZIndex=TRUE)\n      ) %>%\n      hideGroup(c(\"traits de rive\",\"ensembles urbains\")) %>% \n      \n      ## OH de base :\n      addPolygons(data=OH_geom_pg_4326,\n                  stroke = TRUE,\n                  weight=1,\n                  opacity=0.7,\n                  color=~palette_fonctions(OH_geom_pg_4326@data$V_URB),\n                  group=\"géometries\",\n                  popup=popup_pg_tout) %>%\n      addCircles(data=OH_geom_pt_4326,\n                 radius=10,\n                 color=~palette_fonctions(OH_geom_pt_4326@data$V_URB),\n                 stroke = FALSE,\n                 fillOpacity = 0.7,\n                 group=\"géometries\",\n                 popup=popup_pt_tout) %>%\n      ## polyligne : uniquement voierie aménagement >> fait buguer quand on l'enlève > if ?\n      addPolylines(data=OH_geom_pl_4326,\n                   weight=1,\n                   color=~palette_fonctions(OH_geom_pl_4326@data$V_URB),\n                   opacity= 0.7,\n                   group=\"géometries\",\n                   popup = popup_pl_tout) %>%\n      \n      addLegend(position=\"bottomlef\", title = \"Valeurs urbaines des OH\", pal = palette_fonctions, values = OH_ponctuels_4326@data$V_URB, opacity = 1) %>%\n      \n      addPolygons(data=ens_urb,\n                  group=\"ensembles urbains\",\n                  color=\"black\",\n                  fill=FALSE,\n                  weight=2,\n                  popup=popup_ens_urb_tout) %>%\n      addPolylines(data=traits_rive,\n                   group=\"traits de rive\",\n                   color=\"blue\",#pointillés ?\n                   weight=3,\n                   popup=popup_traits_rive_tout)\n\n  })\n\n\n  #2. Declaration des reactive objects\n\n  #OH\n  OH_ponctuels_subset <- reactiveValues(tab = NA)\n  OH_pt_subset <- reactiveValues(tab = NA)\n  OH_pl_subset <- reactiveValues(tab = NA)\n  OH_pg_subset <- reactiveValues(tab = NA)\n  #contexte\n  ens_urb_subset <- reactiveValues(tab = NA)\n  traits_rive_subset <- reactiveValues(tab = NA)\n  #couleurs\n  legende <- reactiveValues(\n    couleurs_pt = NA,\n    couleurs_pg = NA,\n    couleurs_pl= NA,\n    alpha_polygones = NA,\n    pal_legend = NA,\n    val_legend = NA,\n    title_legend = NA)\n    \n  #3. INPUT > INPUT : Mise à jour slider temps selon autres éléments (graphes et élements textes)\n  observe({\n    req(input$ohfreq_brush$xmin,input$ohfreq_brush$xmax)\n    updateSliderInput(session = session,\n                      inputId = \"limites\",\n                      # value=c(subset_limites_temps$date_min,subset_limites_temps$date_max)\n                      value=c(input$ohfreq_brush$xmin,input$ohfreq_brush$xmax)\n    )\n  })\n\n\n  observeEvent(input$selec_bornes_temps, {\n    req(input$borne_temps_1, input$borne_temps_2)\n    updateSliderInput(session = session,\n                      inputId = \"limites\",\n                      # value=c(subset_limites_temps$date_min,subset_limites_temps$date_max)\n                      value=c(input$borne_temps_1,input$borne_temps_2))\n  })\n\n  #4. INPUT > DONNEES : sélection des subset en fonction des INPUTS\n\n  ##contextes (temps)\n  observe({\n    # req(max(input$limites), min(input$limites))\n    ens_urb_subset$tab <- subset(ens_urb, date_debut<=max(input$limites) & date_fin>=min(input$limites))\n\n  })\n\n  observe({\n    # req(max(input$limites), min(input$limites))\n    traits_rive_subset$tab <- subset(traits_rive, DEBUT<=max(input$limites) & FIN>=min(input$limites))\n\n  })\n\n  ##Objets Historiques (temps, fonctions)\n  observe({\n    # req(max(input$limites), min(input$limites), input$choix_fonctions)\n\n    #quel que soit l'élément - temporel ou fonctionnel - qui change, tout le subset est recalculé\n    OH_ponctuels_subset$tab <- subset(OH_ponctuels_4326, DATE_DEB<=max(input$limites) & DATE_FIN>=min(input$limites) & #temps\n                                        V_URB %in% c(input$choix_fonctions[1:6])) #fonction urbaine\n    updateTextInput(session, \"test\", value = length(OH_ponctuels_subset$tab)) #besoin même si pas affiché pour calculs des OH sur les trois geom en même temps\n    OH_pg_subset$tab <- subset(OH_geom_pg_4326, DATE_DEB<=max(input$limites) & DATE_FIN>=min(input$limites) & #temps\n                                 V_URB %in% c(input$choix_fonctions[1:6])) #fonction urbaine\n    OH_pl_subset$tab <- subset(OH_geom_pl_4326, DATE_DEB<=max(input$limites) & DATE_FIN>=min(input$limites) & #temps\n                                 V_URB %in% c(input$choix_fonctions[1:6])) #fonction urbaine\n    OH_pt_subset$tab <- subset(OH_geom_pt_4326, DATE_DEB<=max(input$limites) & DATE_FIN>=min(input$limites) & #temps\n                                 V_URB %in% c(input$choix_fonctions[1:6])) #fonction urbaine\n\n  })\n\n  #5. INPUT > OUTPUT\n\n  #COULEURS LEGENDE SELON CHOIX\n  observe ({\n\n    if (input$couleur_OH == \"v_urb\") # afficher selon valeurs urbaines\n    {\n      # legende$couleurs_ponctuels <- ~palette_fonctions(OH_ponctuels_subset$tab@data$V_URB)\n      legende$couleurs_pt <- ~palette_fonctions(OH_pt_subset$tab@data$V_URB)\n      legende$couleurs_pg <- ~palette_fonctions(OH_pg_subset$tab@data$V_URB)\n      legende$couleurs_pl <- ~palette_fonctions(OH_pl_subset$tab@data$V_URB)\n      legende$alpha_polygones <- 0.7\n      legende$pal_legend <- palette_fonctions\n      legende$val_legend <- OH_ponctuels_subset$tab@data$V_URB\n      legende$title_legend <- \"Valeurs urbaines des OH\"}\n\n    else if (input$couleur_OH == \"portee\") # afficher selon portée\n    {\n      #legende$couleurs_ponctuels <- ~palette_portees(OH_ponctuels_subset$tab@data$PORTEE)\n      legende$couleurs_pt <- ~palette_portees(OH_pt_subset$tab@data$PORTEE)\n      legende$couleurs_pg <- ~palette_portees(OH_pg_subset$tab@data$PORTEE)\n      legende$couleurs_pl <- ~palette_portees(OH_pl_subset$tab@data$PORTEE)\n      legende$alpha_polygones <- 0.8\n      legende$pal_legend <- palette_portees\n      legende$val_legend <- OH_ponctuels_subset$tab@data$PORTEE\n      legende$title_legend <- \"Niveau de portée des OH (1=min, 4=max)\"}\n\n    else if (input$couleur_OH == \"duree\") # afficher selon durée d'existence\n      #couleurs calculées sur le même intervalle (le plus global == OH_ponctuels) sinon cela devrait donner une légende différente pour chaque type de geom\n    {\n      #legende$couleurs_ponctuels  <- ~ramp_duree(OH_ponctuels_subset$tab@data$DATE_FIN - OH_ponctuels_subset$tab@data$DATE_DEB)\n      legende$couleurs_pt  <- ~ramp_duree(OH_ponctuels_subset$tab@data$DATE_FIN - OH_ponctuels_subset$tab@data$DATE_DEB)\n      legende$couleurs_pg  <-  ~ramp_duree(OH_ponctuels_subset$tab@data$DATE_FIN - OH_ponctuels_subset$tab@data$DATE_DEB)\n      legende$couleurs_pl  <-  ~ramp_duree(OH_ponctuels_subset$tab@data$DATE_FIN - OH_ponctuels_subset$tab@data$DATE_DEB)\n      legende$alpha_polygones <- 0.8\n      legende$pal_legend <- ramp_duree\n      legende$val_legend <- (OH_ponctuels_subset$tab@data$DATE_FIN - OH_ponctuels_subset$tab@data$DATE_DEB)\n      legende$title_legend <- \"Durée d'existence des OH\"}\n\n\n  })\n\n  #MAP OUTPUT\n  observe ({\n\n    ## POPUP\n    # popup_ponctuels <-texte_popup_OH(OH_ponctuels_subset$tab)\n    popup_pg <-texte_popup_OH(OH_pg_subset$tab)\n    popup_pl <-texte_popup_OH(OH_pl_subset$tab)\n    popup_pt <-texte_popup_OH(OH_pt_subset$tab)\n    popup_ens_urb <- texte_popup_ens_urb(ens_urb_subset$tab)\n    popup_traits_rive <- texte_popup_traits_rive(traits_rive_subset$tab)\n\n    ## CARTE\n    leafletProxy(\"map\") %>%\n      clearShapes() %>%\n      clearMarkers() %>%\n      clearControls() %>%\n      addPolygons(data=OH_pg_subset$tab,\n                  stroke = TRUE,\n                  weight=1,\n                  opacity=legende$alpha_polygones,\n                  color=legende$couleurs_pg,\n                  group=\"géometries\",\n                  popup=popup_pg) %>%\n      addCircles(data=OH_pt_subset$tab,\n                 radius=10,\n                 color=legende$couleurs_pt,\n                 stroke = FALSE,\n                 fillOpacity = 0.7,\n                 group=\"géometries\",\n                 popup=popup_pt) %>%\n      ## polyligne : uniquement voierie aménagement >> fait buguer quand on l'enlève > if ?\n      addPolylines(data=OH_pl_subset$tab,\n                   weight=1,\n                   color=legende$couleurs_pl,\n                   opacity= 0.7,\n                   group=\"géometries\",\n                   popup = popup_pl) %>%\n\n      addLegend(position=\"bottomlef\", title = legende$title_legend, pal = legende$pal_legend, values = legende$val_legend, opacity = 1) %>%\n\n      addPolygons(data=ens_urb_subset$tab,\n                  group=\"ensembles urbains\",\n                  color=\"black\",\n                  fill=FALSE,\n                  weight=2,\n                  popup=popup_ens_urb) %>%\n      addPolylines(data=traits_rive_subset$tab,\n                   group=\"traits de rive\",\n                   color=\"blue\",#pointillés ?\n                   weight=3,\n                   popup=popup_traits_rive)\n    #possible d'ajouter className pour css\n    #possible d'ajouter un ID pour suppprimer + spécifiquement cette légende\n  })\n\n  #GRAPHS OUTPUT\n  # Graphe de répartition des objets dans le temps entre date min et date max\n  # Avec surlignage de la sélection temporelle\n  # vals <- reactiveValues(pdata=ggplot())\n  # #creation du graphe\n  # observe({\n  #   date_min <- min(input$limites)\n  #   date_max <- max(input$limites)\n  #   echelle <- input$plot_echelle_y\n  #\n  #   subset_m_fonction_an <- subset(m_fonction_an, m_fonction_an$annee<=date_max & m_fonction_an$annee>=date_min)\n  #\n  #   # output$ohfreq <- renderPlot({\n  #   p <- ggplot()+\n  #     geom_bar(data = m_fonction_an,\n  #              aes(x=annee, y=value),\n  #              stat=\"identity\",\n  #              width=1,\n  #              fill=\"#CDD2D4\") +\n  #     geom_bar(data = subset_m_fonction_an,\n  #              aes(x=annee, y=value, fill=variable),\n  #              stat = \"identity\",\n  #              width=1)+\n  #     scale_fill_manual(values=adjustcolor(palette, alpha.f=0.8))+\n  #     ggtitle(\"Nombre d'OH par année et par valeur urbaine\")+\n  #     xlab(\"année\")+\n  #     ylab(\"Nombre d'OH\")+\n  #     theme_hc()+\n  #     theme_facettes_clair()+\n  #     facet_wrap(~ v_urb, scales=echelle, nrow=2)\n  #\n  #   vals$data <- p\n  #   #     },\n  #   #     bg=\"transparent\")\n  # })\n\n  #affichage\n  # observeEvent(vals$data,{\n  #   output$ohfreq <- renderPlot({isolate(vals$data)}, bg=\"transparent\")\n  # })#tout aussi long\n  #\n  #6. INTERACTIONS AUTRES\n\n  # mise en valeur de l'OH sélectionnée >> à gérer par rapport à la géométrie : zoom sur bounding box de la geom / mise en valeur des points et geom\n  observeEvent(input$selec_OH, {\n\n    #*******\n    #A FAIRE\n    #catch si pas numéro > ifelse sur typeof de la variable\n    # voir si zoom sur bouding box (pbm avec les points et les petits polygones)\n    #*******\n\n    ## selection selon le type de géométrie\n    leafletProxy(\"map\") %>% clearGroup(\"selection\")\n    choix_OH <- as.numeric(input$num_OH)\n\n    if (nrow(subset(OH_pg_subset$tab@data, OH_NUM == choix_OH))>0) {\n\n      this.OH_geom <- subset(OH_pg_subset$tab, OH_NUM ==  choix_OH)\n      # this.OH_ponctuel <- subset(OH_ponctuels_subset$tab, OH_NUM ==  choix_OH)\n      this.coords <- coordinates(this.OH_geom)\n      this.x <-  this.coords[1]\n      this.y <- this.coords[2]\n      this.popup <- texte_popup_OH(this.OH_geom)  ## POPUP\n\n      leafletProxy(\"map\") %>%\n        setView(lat=this.y, lng=this.x, zoom = 18) %>%\n        addPolygons(data=this.OH_geom,\n                    stroke = TRUE,\n                    color= \"black\",\n                    opacity= 0.7,\n                    weight= 5,\n                    fill = FALSE,\n                    group=\"selection\",\n                    popup=this.popup)\n\n\n    }\n\n    else if (nrow(subset(OH_pl_subset$tab@data, OH_NUM == choix_OH))>0) {\n\n      this.OH_geom <- subset(OH_pl_subset$tab, OH_NUM ==  choix_OH)\n      # this.OH_ponctuel <- subset(OH_ponctuels_subset$tab, OH_NUM ==  choix_OH)\n      this.coords <- coordinates(this.OH_geom)\n      this.x <-  this.coords[1]\n      this.y <- this.coords[2]\n      this.popup <- texte_popup_OH(this.OH_geom)\n\n      leafletProxy(\"map\") %>%\n        setView(lat=this.y, lng=this.x, zoom = 18) %>%\n        addPolylines(data=this.OH_geom,\n                     weight=4,\n                     stroke=\"black\",\n                     group=\"selection\",\n                     popup=this.popup)\n\n    }\n\n    else if (nrow(subset(OH_pt_subset$tab@data, OH_NUM == choix_OH))>0) {\n\n      this.OH_geom <- subset(OH_pt_subset$tab, OH_NUM ==  choix_OH)\n      # this.OH_ponctuel <- subset(OH_ponctuels_subset$tab, OH_NUM ==  choix_OH)\n      this.coords <- coordinates(this.OH_geom)\n      this.x <-  this.coords[1]\n      this.y <- this.coords[2]\n      this.popup <- texte_popup_OH(this.OH_geom)\n\n      leafletProxy(\"map\") %>%\n        setView(lat=this.y, lng=this.x, zoom = 18) %>%\n        addCircles(data=this.OH_geom,\n                   radius=10,\n                   stroke = TRUE,\n                   color= \"black\",\n                   opacity= 0.7,\n                   weight= 5,\n                   fill = FALSE,\n                   group=\"selection\",\n                   popup=this.popup)\n\n\n    }\n\n    else {updateTextInput(session, \"num_OH\", value = \"aucun OH correspondant\")}\n\n  })\n\n  #suppression selection\n  observeEvent(input$deselec_OH, {leafletProxy(\"map\") %>% clearGroup(\"selection\")})\n\n})\n\n\n",
    "created" : 1494974325745.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3079318079",
    "id" : "4A289F60",
    "lastKnownWriteTime" : 1495015559,
    "last_content_update" : 1495015559399,
    "path" : "C:/Users/lue/Sync/1recherche/1these/SIG/VISU/shiny/explOH/server.r",
    "project_path" : "server.r",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}