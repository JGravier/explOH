{
    "collab_server" : "",
    "contents" : "# création tableaux de contingence---------------------------------------------------------------\ncreation_tab_cont <- function(sequence){\n  bornes_deb <- head(sequence, -1)\n  bornes_fin <- tail(sequence, -1)\n  tabcont <- data.frame(deb=bornes_deb,fin=bornes_fin)\n  tabcont$periode <-paste(tabcont$deb,tabcont$fin,sep=\"-\")\n  #compte des v_urb > avec boucle\n  for (n in sort(unique(OHafc$v_urb))){ # pour toutes les valeurs urbaines\n    nom_col <- paste(\"v_urb\",n,sep=\".\") # creer une nouvelle colonne \n    for (i in 1:length(tabcont$deb)) { \n      tabcont[i,nom_col] <- sum (OHafc$v_urb==n & OHafc$DISPARITIO>=tabcont$deb[i] & OHafc$APPARITION<tabcont$fin[i])\n    } # remplir cette colonne de la somme des individus ayant cette valeur urbaine et ayant existé dans les bornes données\n  }\n  #compte des v_usage\n  for (n in sort(unique(OHafc$V_USAGE))){\n    nom_col <- paste(\"v_usage\",n,sep=\".\") # creer une nouvelle colonne \n    for (i in 1:length(tabcont$deb)) { \n      tabcont[i,nom_col] <- sum (OHafc$V_USAGE==n & OHafc$DISPARITIO>=tabcont$deb[i] & OHafc$APPARITION<tabcont$fin[i])\n    }\n  }\n  #compte des portees\n  for (n in sort(unique(OHafc$portee))){\n    nom_col <- paste(\"portee\",n,sep=\".\") # creer une nouvelle colonne \n    for (i in 1:length(tabcont$deb)) { \n      tabcont[i,nom_col] <- sum (OHafc$portee==n & OHafc$DISPARITIO>=tabcont$deb[i] & OHafc$APPARITION<tabcont$fin[i])\n    }\n  }\n  row.names(tabcont)<-tabcont$periode\n  return(tabcont)\n}\n\n# summary.variance.dudi -------------------------------------------------------------------------\n# Crée un tableau pour résumer la variance expliquée par chaque axe + mise en forme pour plotter\n# Entrée : data = resultat dudi.coa\n# Sortie : data.frame avec {n° de composante, variance, % de la variance, variance résultante, factor pour couleur}\n\nsummary.variance.dudi <- function(data){\n  expected_inertia <- 100/max(data$rank)\n  summaryAFC <- data.frame(\n    COMP = seq(1,max(data$rank),1), \n    EIG = data$eig,\n    PCTVAR = 100*data$eig / sum(data$eig),\n    CUMPCTVAR = cumsum(100*data$eig / sum(data$eig)))\n  summaryAFC$CUTSCOLOR <- cut(summaryAFC$PCTVAR, breaks=c(0,expected_inertia,Inf))\n  return(summaryAFC)\n}\n\n# barplot.dudi.variance -----------------------------------------------------------------\n# Crée un graphique barplot de la variance expliquée par chaque axe d'un résultat d'AFC\n# Entrée : data = resultat dudi.coa + sumdata = résultat summary.variance.dudi\n# Sortie : un objet ggplot\n\n#paste(as.character(substitute(data)), # ligne pour récupérer le nom de la variable\n\nbarplot.dudi.variance <- function(data, sumdata, titre, soustitre=\"\"){\n  expected_inertia <- 100/max(data$rank)\n  plot <- ggplot(data=sumdata, aes(x=COMP, y=PCTVAR, fill=sumdata$CUTSCOLOR)) +\n    geom_bar(stat=\"identity\") +\n    labs(x=\"Composantes\",\n         y=\"Part de la variance expliquée\",\n         title= titre,\n         subtitle=soustitre,\n         caption=\"L. Nahassia, Géographie-cités, 2018 | Sources : ToToPI, LAT, CITERES\")+\n    #     geom_text(aes(label=paste(round(PCTVAR),\"%\",sep=\"\"),color = sumdata$CUTSCOLOR), \n    #               vjust=1.2,\n    #               hjust=0.4,\n    #               fontface = \"bold\",\n    #               size=10) +\n    scale_fill_manual(values=alpha(c(\"grey60\",\"darkslategray3\"), 0.8), labels=c(\"Axe non conservé dans l'analyse\", \"Axe conservé dans l'analyse\") ) +\n    geom_hline(aes(yintercept=expected_inertia), colour=\"turquoise4\", linetype=\"dashed\")+\n    geom_text(x=max(sumdata$COMP)+0.5, \n              y=expected_inertia+1,\n              label=paste(\"inertie moyenne attendue par composante : \", round(expected_inertia, digits=2), \"%\", sep=\"\"),\n              vjust=0,\n              hjust=1,\n              colour=\"turquoise4\",\n              alpha=0.5,\n              size=3)+\n    theme_fivethirtyeight()+\n    theme_ln()+\n    theme(legend.position = \"bottom\",\n          legend.title = element_blank())\n  return(plot)\n}\n\n\n# biplot.AFC -----------------------------------------------------------------\n# Crée un graphique biplot des résultats de l'AFC sur les 2 premiers axes (variables+individus)\n# Entrée : data = resultat dudi.coa  ; variable_color = palette pour les variables ; liste_variable = nom des variables ; axes = liste des 2 axes à ploter\n# Sortie : un objet ggplot\n\nbiplot.AFC <- function(data, axe, variable_color, liste_variable, titre, soustitre){\n  pctvar_A1 <- round(data$eig[axe[[1]]]*100/sum(data$eig))\n  pctvar_A2 <- round(data$eig[axe[[2]]]*100/sum(data$eig))\n  if(nrow(data$li) > 50){lab_periode <- data$li[seq(1,nrow(data$li),2),]} else {lab_periode <- data$li} #selection d'une ligne sur 2 si nombre de périodes trop grand pour lisibilité\n  \n  ggplot()+\n    geom_hline(aes(yintercept=0), colour=\"gray25\")+\n    geom_vline(aes(xintercept=0), colour=\"gray25\")+\n    labs(title=titre,\n         subtitle=soustitre,\n         x=paste(\"Composante n°\", axe[[1]], \" (\",pctvar_A1, \"% de variance expliquée)\", sep=\"\"),\n         y=paste(\"Composante n°\", axe[[2]],\" (\",pctvar_A2, \"% de variance expliquée)\", sep=\"\"),\n         caption=\"L. Nahassia, Géographie-cité, 2018 | Sources : ToToPI, LAT, CITERES\"\n    )+\n    # élargissement des limites du plot\n    expand_limits(x=c(min(data$li[,axe[[1]]])-0.1, max(data$li[,axe[[1]]])+0.1), y=c(min(data$li[,axe[[2]]])-0.1, max(data$li[,axe[[2]]])))+ \n    # points des variables  \n    geom_point(data=data$co,\n               mapping=aes(x=data$co[,axe[[1]]], y=data$co[,axe[[2]]]), #choix des composantes i et j\n               shape=16,\n               size=7,\n               colour=variable_color)+\n    #labels variables\n    geom_text(data=data$co,\n              mapping=aes(x=data$co[,axe[[1]]], y=data$co[,axe[[2]]],label=liste_variable),\n              colour=\"white\",\n              fontface=\"bold\")+\n    # lignes reliant les individus\n    geom_path(data=data$li, \n              mapping=aes(x=data$li[,axe[[1]]], y=data$li[,axe[[2]]]),\n              linetype=\"dotted\",\n              colour= \"gray18\")+ #bcp trop compliqué de faire une line avec gradient\n    #label des individus\n    geom_text_repel(data=lab_periode,\n                    mapping=aes(x=lab_periode[,axe[[1]]], y=lab_periode[,axe[[2]]],label=rownames(lab_periode)),\n                    force=2,\n                    # max.iter = 1000,\n                    box.padding = unit(0.4, \"lines\"), \n                    size=3,\n                    colour=color_ramp_ind(nrow(lab_periode)),\n                    segment.color=\"grey60\")+\n    #points des individsu\n    geom_point(data=data$li, \n               mapping=aes(x=data$li[,axe[[1]]], y=data$li[,axe[[2]]]),\n               shape=18,\n               size=4,\n               colour= color_ramp_ind(nrow(data$li)))+\n    theme_fivethirtyeight()+\n    theme_ln()\n  \n  \n  \n}\n\n# heat.contribvar-----------------------------------------------------------------\n# Crée une heat map comme un tableau pour analyser les contributions et les cos²\n# Entrée : data = tableau à préparer (nom des variables), à partir de inertia.dudi\n# Sortie : affiche un objet ggdraw, retourne le ggplot sans axes inversés\n\nheat.contribvar<- function(data, titre, soustitre=\"\", couleur, gestion_dates=FALSE) {\n  \n  if (gestion_dates==TRUE){    #prepa données quand data = périodes (melt + tri)\n    data$periodes <- row.names(data)\n    data.m <- melt(data=data, id.vars = \"periodes\")\n    data.m$periodes_sort <- word(data.m$periodes,1,sep = \"\\\\-\")#sélection des dates avant \"-\" /!\\ remettre -25 qui disparaît forcément\n    data.m[grep(\"^-25\",data.m$periodes),]$periodes_sort <- -25 # -25 remis en premières date\n    yvar <- as.factor(data.m$periodes_sort)\n    ylabs <- data.m$periodes\n  }\n  else if(gestion_dates==FALSE) # prépa données quand data =! périodes\n  {\n    data$variables <- row.names(data)\n    data.m <- melt(data=data, id.vars = \"variables\")\n    yvar <- data.m$variables\n    ylabs <- data.m$variables\n  }\n  \n  if(nrow(data) > 50){taille_ticks_text <- 6} else {taille_ticks_text <- 7} #selection d'une ligne sur 2 si nombre de périodes trop grand pour lisibilité\n  \n  #data.m$periodes_sort <- data.m$periodes_sort %>% as.numeric()\n  \n  # #gestion transparence possible\n  # geom_tile(color = \"white\", fill= \"grey85\")+\n  #   geom_tile(aes(fill=value, alpha = value), color = \"white\")+\n  #   scale_fill_gradient(low=\"white\", high=\"red\")+\n  \n  #plot\n  ggplot(data.m, aes(x=variable, y=yvar))+ #y pour axe dans l'ordre\n    geom_tile(aes(fill=value), color = \"grey87\")+\n    scale_y_discrete(\n      expand=c(0,0),\n      labels=ylabs #labels périodes entières\n    ) +\n    scale_x_discrete(expand = c(0, 0))+\n    scale_fill_gradient(low=\"white\", high=couleur)+\n    labs(\n      title =titre,\n      subtitle =soustitre,\n      caption=\"L. Nahassia, Géographie-cités, 2018 | Sources : ToToPI, LAT, CITERES\",\n      x=\"\",\n      y=\"\",\n      fill= \"%\")+\n    theme_fivethirtyeight()+\n    theme_ln()+\n    theme( \n      panel.grid = element_blank(),\n      panel.background\t= element_blank(),\n      axis.ticks = element_blank(), #pour ne pas voir les ticks et title\n      axis.text.y= element_text( size=taille_ticks_text, margin=margin(t=-4, unit=\"pt\")),\n      legend.position = \"right\",\n      legend.direction = \"vertical\",\n      legend.background = element_blank())\n}\n",
    "created" : 1530765504466.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1004775474",
    "id" : "F60C2628",
    "lastKnownWriteTime" : 1528930985,
    "last_content_update" : 1528930985,
    "path" : "D:/Sync/1recherche/1these/SIG/VISU/shiny/explOH_11b/6_2_global_fonctions_AFC.R",
    "project_path" : "6_2_global_fonctions_AFC.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}