{
    "collab_server" : "",
    "contents" : "################################\n# Shiny app pour afficher les objets selon le temps avec leaflet\n# L. Nahassia, mai 2018\n# Server pour explOH_11\n################################\n\n#####\nlibrary(shiny)\n\nshinyServer(function(input, output, session) {\n  \n  \n  ###########################################################################\n  ##################### ONGLET 1 : exploration carte OH #####################\n  ###########################################################################\n  \n  #nombre random pour frise début\n  date_random <- sample (-25:2015, 2)\n  \n  \n  #----------------------------------- #1.1. carte de base ----\n  #ne rien mettre dedans qui change\n  output$map <- renderLeaflet({\n    \n    leaflet() %>%\n      setView(lat=47.394211, lng=0.687247, zoom = 15) %>%\n      \n      ##tiless\n      addProviderTiles(\"CartoDB.Positron\", group=\"clair\") %>%\n      addProviderTiles(\"Esri.WorldImagery\", group = \"satellite\") %>%\n      addTiles(options = tileOptions(opacity =0), attribution=\" données : ToToPI, UMR7324 CITERES-LAT Université de Tours/CNRS\", group=c(\"clair\", \"satellite\")) %>% \n      ##échelle\n      addScaleBar(position=\"bottomright\", scaleBarOptions(imperial=FALSE)) %>% \n      \n      ##layer control\n      addLayersControl(\n        baseGroups = c(\"clair\", \"satellite\"),\n        overlayGroups = c(\"géometries des OH\", \"ensembles urbains\", \"traits de rive\", \"pôles urbains\"),\n        options=layersControlOptions(autoZIndex=TRUE)) %>%\n      hideGroup(c(\"traits de rive\",\"ensembles urbains\", \"pôles urbains\")) %>%    \n      \n      #légende\n      addLegend(position=\"bottomleft\", \n                title = \"Valeurs urbaines des OH\", \n                pal =  palette_fonctions, \n                values = OH_geom$V_URB_NOM, \n                opacity = 1) %>% \n      \n      #bouton pour export\n      onRender(\n        \"function(el, x) {\n            L.easyPrint({\n              title:'Enregistrer la carte',\n              sizeModes: ['Current', 'A4Landscape', 'A4Portrait'],\n              filename: 'export_carte',\n              exportOnly: true,\n              hideClasses: ['.leaflet-control-zoom','leaflet-control-layers'],\n              hideControlContainer:false,\n              customSpinnerClass:'epLoader',\n              tileWait:1000\n            }).addTo(this);\n            }\"\n      )\n  })\n  \n  \n  #----------------------------------- #1.2. Declaration des reactive objects ----\n  #OH à supprimer, ajouter, et tableau en memoire (au début toutes dates toutes valeurs urbaines)\n  OH_subset <- reactiveValues(\n    OH_A = OH_geom,\n    OH_B = NULL,\n    ID_del= NULL,\n    ID_add = NULL,\n    tab_add = NULL,\n    message = NULL\n  )\n  #contexte\n  ens_urb_subset <- reactiveValues(tab = ens_urb)\n  traits_rive_subset <- reactiveValues(tab = traits_rive)\n  poles_subset <- reactiveValues(tab=poles)\n  #couleurs\n  legende <- reactiveValues(\n    alpha_polygones = NA,\n    pal_couleurs= NA,\n    pal_legend = NA,\n    val_legend = NA,\n    title_legend = NA)\n  \n  \n  #----------------------------------- #1.3. INPUT > INPUT : Mise à jour slider temps selon autres éléments (graphes et élements textes) ----\n  \n  #date de départ pour lancer l'appli\n  req(date_random)\n  updateSliderInput(session = session,\n                    inputId = \"limites\",\n                    value=c(min(date_random),max(date_random)))\n  \n  observeEvent(input$selec_bornes_temps, {\n    req(input$borne_temps_1, input$borne_temps_2)\n    updateSliderInput(session = session,\n                      inputId = \"limites\",\n                      # value=c(subset_limites_temps$date_min,subset_limites_temps$date_max)\n                      value=c(input$borne_temps_1,input$borne_temps_2))\n  })\n  \n  #----------------------------------- #1.4. INPUT > DONNEES : sélection des subset en fonction des INPUTS ----\n  \n  ##contextes (temps)\n  observe({\n    \n    req(max(input$limites), min(input$limites))\n    ens_urb_subset$tab <- ens_urb %>% filter (date_debut<=max(input$limites) & date_fin>=min(input$limites))\n    traits_rive_subset$tab <- traits_rive %>% filter (DEBUT<=max(input$limites) & FIN>=min(input$limites))\n    poles_subset$tab <- poles %>% filter (date_deb<=max(input$limites) & date_fin>=min(input$limites))\n    \n  })\n  \n  ##Objets Historiques (temps, fonctions)\n  observe({\n    req(max(input$limites), min(input$limites))\n    \n    val_usage <- lapply(\n      1:6, \n      function(i){\n        substring(\n          eval(parse(text=paste(\"input$picker_vurb_\",i,sep=\"\"))), #récupère toutes les options cochées\n          1,2 #ne garde que les deux premiers caractères (=les numéros)\n        )\n      }) %>% unlist %>% as.numeric\n    \n    tab <- OH_geom %>% filter(V_USAGE %in% val_usage)\n    updateTextInput(session,\"test\", value=nrow(tab))\n    \n    #subset demandé par utilisateur\n    OH_subset$OH_B <- OH_geom %>%\n      filter(DATE_DEB<=max(input$limites)) %>%\n      filter(DATE_FIN>=min(input$limites)) %>%\n      filter(V_USAGE %in% val_usage)\n    #comparaison des ID du subset actuel et du subset précédent (OH_A)\n    OH_subset$ID_del <- setdiff(OH_subset$OH_A$OH_NUM, OH_subset$OH_B$OH_NUM) #ID des Shapes à supprimer\n    OH_subset$ID_add <- setdiff(OH_subset$OH_B$OH_NUM, OH_subset$OH_A$OH_NUM) #ID des Shapes à ajouter\n    #subset des OH à ajouter\n    OH_subset$tab_add <- OH_geom %>% filter(OH_NUM %in% OH_subset$ID_add)\n    #subset actuel mis en mémoire\n    OH_subset$OH_A <- OH_subset$OH_B\n    \n    #message HTML nombre d'OH affichés\n    OH_subset$message <- paste(nrow(OH_subset$OH_B), \" OH correspondants à la sélection\", sep=\"\")\n    \n  })\n  \n  \n  \n  #----------------------------------- #1.5. INPUT > OUTPUT ----\n  \n  #CHANGEMENT COULEURS\n  ## quand l'utilisateur choisi de modifier le type de legende\n  ## > modification des couleurs et des valeurs pour construire la légende\n  ## > réinitialisation des OH à afficher\n  observeEvent (input$couleur_OH, {\n    if (input$couleur_OH == \"v_urb\") # afficher selon valeurs urbaines\n    { legende$alpha_polygones <- 0.7 \n    legende$pal_couleurs <- palette_fonctions\n    legende$pal_legend <- palette_fonctions\n    legende$val_legend <- OH_geom$V_URB_NOM\n    legende$title_legend <- \"Valeurs urbaines des OH\"}\n    \n    else if (input$couleur_OH == \"portee\") # afficher selon portée\n    { legende$alpha_polygones <- 0.9\n    legende$pal_couleurs <- palette_portees\n    legende$pal_legend <- palette_portees\n    legende$val_legend <- as.factor(OH_geom$PORTEE_NOM)\n    legende$title_legend <- \"Niveau de portée des OH\"}\n    \n    else if (input$couleur_OH == \"fiab\") # afficher selon fiabilité\n    { legende$alpha_polygones <- 0.9\n    legende$pal_couleurs <- palette_fiab\n    legende$pal_legend <- palette_fiab\n    legende$val_legend <- as.factor(OH_geom$FIAB_APP)\n    legende$title_legend <- \"Fiabilité de la date d'apparition des OH\"}\n    \n    #Subset en cours d'affichage (OH_A) à redessiner\n    OH_subset$tab_add <- OH_subset$OH_A\n    \n    \n    #changement de légende\n    leafletProxy(\"map\") %>%\n      clearControls() %>%\n      addLegend(position=\"bottomlef\", title = legende$title_legend, pal = legende$pal_legend, values = legende$val_legend, opacity = 1)\n    \n  })\n  \n  #MAP OUTPUT\n  \n  observe ({\n    OH_add <- OH_subset$tab_add    \n    OH_pt <- OH_add[st_geometry_type(OH_add)==\"POINT\",] %>% st_cast(\"POINT\")\n    #ajout d'un OH dummy à OH_pt pour contourner le bug de leafletProxy avec df vide (OH généré dans global)\n    OH_pt <- rbind(OH_pt, null_row)\n    OH_pg <- OH_add[st_geometry_type(OH_add)==\"MULTIPOLYGON\",] %>% st_cast(\"MULTIPOLYGON\")\n    OH_pl <- OH_add[st_geometry_type(OH_add)==\"MULTILINESTRING\",] %>% st_cast(\"MULTILINESTRING\")\n    \n    #couleurs des OH \n    if (input$couleur_OH == \"v_urb\")\n    { couleurs_pg<- ~legende$pal_couleurs(OH_pg$V_URB_NOM)\n    couleurs_pl<- ~legende$pal_couleurs(OH_pl$V_URB_NOM)\n    couleurs_pt <- ~legende$pal_couleurs(OH_pt$V_URB_NOM)}\n    else if (input$couleur_OH == \"portee\")\n    {  couleurs_pg <- ~legende$pal_couleurs(OH_pg$PORTEE_NOM)\n    couleurs_pl<- ~legende$pal_couleurs(OH_pl$PORTEE_NOM)\n    couleurs_pt <- ~legende$pal_couleurs(OH_pt$PORTEE_NOM)}\n    else if (input$couleur_OH == \"fiab\")\n    {  couleurs_pg <- ~legende$pal_couleurs(OH_pg$FIAB_APP)\n    couleurs_pl<- ~legende$pal_couleurs(OH_pl$FIAB_APP)\n    couleurs_pt <- ~legende$pal_couleurs(OH_pt$FIAB_APP)}\n    \n    #POPUP\n    popup_ens_urb <- texte_popup_ens_urb(ens_urb_subset$tab)\n    popup_traits_rive <- texte_popup_traits_rive(traits_rive_subset$tab)\n    popup_poles <- texte_popup_poles(poles_subset$tab)\n    popup_pg <-texte_popup_OH(OH_pg)\n    popup_pl <-texte_popup_OH(OH_pl)\n    popup_pt <-texte_popup_OH(OH_pt)\n    # browser()\n    \n    #date\n    subset_dates <-  paste(\"Période : \", min(input$limites),\" - \" ,max(input$limites), sep=\"\")\n    \n    # CARTE\n    leafletProxy(\"map\", data=OH_pt) %>%\n      clearMarkers() %>%\n      clearGroup(group=c(\"ensembles urbains\", \"traits de rive\", \"poles urbains\")) %>%\n      removeControl(layerId = c(\"nombre\",\"periode\")) %>% \n      #nombre d'OH\n      addControl(position=\"bottomleft\", html=OH_subset$message, layerId = \"nombre\") %>% \n      addControl(position=\"bottomleft\", html=subset_dates, layerId = \"periode\") %>%\n      #contexte\n      addPolygons(data=ens_urb_subset$tab,\n                  group=\"ensembles urbains\",\n                  color=\"black\",\n                  weight=2,\n                  dashArray=\"3,5\",\n                  fill=FALSE,\n                  popup=popup_ens_urb) %>%\n      addPolylines(data=traits_rive_subset$tab,\n                   group=\"traits de rive\",\n                   color=\"blue\",#pointillés ?\n                   weight=3,\n                   dashArray =\"5,5\",\n                   fillOpacity = 0.9,\n                   popup=popup_traits_rive) %>%\n      addMarkers(data=poles_subset$tab,\n                 group=\"pôles urbains\",\n                 icon=~polesIcons[type],\n                 popup=popup_poles) %>%\n      #OH\n      addPolygons(data=OH_pg,\n                  stroke = TRUE,\n                  weight=1,\n                  opacity=legende$alpha_polygones,\n                  color=couleurs_pg,\n                  group=\"géometries des OH\",\n                  layerId= as.character(OH_pg$OH_NUM),\n                  popup=popup_pg ) %>%\n      addCircles(        radius=10, #data passée en argument du leaflet général pour contourner erreur\n                         color=couleurs_pt,\n                         stroke = FALSE,\n                         fillOpacity = 0.7,\n                         group=\"géometries des OH\",\n                         layerId= as.character(OH_pt$OH_NUM),\n                         popup=popup_pt) %>%\n      addPolylines(data=OH_pl,\n                   weight=1,\n                   color=couleurs_pl,\n                   opacity= 0.7,\n                   group=\"géometries des OH\",\n                   layerId= as.character(OH_pl$OH_NUM),\n                   popup = popup_pl) %>%\n      removeShape(layerId=as.character(OH_subset$ID_del)) %>% \n      removeShape(layerId=\"0\")\n    # possible d'ajouter className pour css\n    \n    \n    \n  })\n  \n  \n  #TAB OUTPUT\n  observe({\n    tabOH <- OH_subset$OH_A %>% as.data.frame %>% select(-geom_wkt, -geometry, -QGIS_ID, -V_URB, - V_URB_NOM, -PORTEE_NOM )\n    output$tab_OH <-renderDataTable(\n      tabOH,\n      filter=\"bottom\",\n      options=list(pageLength=10,\n                   info=TRUE,\n                   scrollX=TRUE\n      )\n    )\n    \n  })\n  \n  \n  #tTELECHARGEMENT SUBSET\n  \n  output$downloadData <- downloadHandler(\n    filename = function() {\n      if (input$type_dl == \"geojson\"){return(\"selectionOH.geojson\")}\n      else if(input$type_dl == \"sqlite\"){return(\"selectionOH.sqlite\")}\n      else if(input$type_dl == \"csv\"){return(\"selectionOH.csv\")}\n      else if(input$type_dl == \"shapefile\"){return(\"selectionOH.shp\")}\n    },\n    content = function(file) {\n      dlOH <- st_transform(OH_subset$OH_A, proj_2154) %>% select(-geom_wkt)\n      if(input$type_dl == \"csv\"){st_write(obj=dlOH, dsn=file, layer_options = \"GEOMETRY=AS_WKT\")}\n      else if(input$type_dl == \"geojson\"){st_write(obj=dlOH, dsn=file, layer=\"OH\")}\n      else if(input$type_dl == \"sqlite\"){st_write(obj=dlOH, dsn=file, layer=\"OH\", dataset_options=\"SPATIALITE=YES\", layer_options=\"FORMAT=SPATIALITE\")}\n    }\n  )\n  \n  # output$downloadMap <- downloadHandler(\n  #   filename = \"carte.png\",\n  #   content=function(file){\n  #     mapshot(x=output$map, file=file, remove_controls =c(\"zoomControl\", \"layersControl\"))\n  #     \n  #   })\n  \n  \n  #----------------------------------- #1.6. INTERACTIONS AUTRES ----\n  \n  # mise en valeur de l'OH sélectionnée, même si elle est hors de ce qui est affiché\n  observeEvent(input$selec_OH_search, {\n    \n    #*******\n    #A FAIRE\n    # voir si zoom sur bouding box (pbm avec les points et les petits polygones)\n    #*******\n    \n    ## selection selon le type de géométrie\n    # leafletProxy(\"map\") %>% clearGroup(\"selection\")\n    choix_OH <- input$selec_OH\n    \n    if (nrow(OH_geom[OH_geom$OH_NUM == choix_OH,])>0)\n    {if (st_geometry_type(OH_geom[OH_geom$OH_NUM == choix_OH,])==\"MULTIPOLYGON\") {\n      \n      this.OH_geom <- OH_geom[OH_geom$OH_NUM == choix_OH,] %>% st_cast(\"MULTIPOLYGON\")\n      # this.OH_ponctuel <- subset(OH_ponctuels_subset$tab, OH_NUM ==  choix_OH)\n      this.coords <- st_bbox(this.OH_geom)\n      this.x <-  this.coords[[1]]\n      this.y <- this.coords[[2]]\n      this.popup <- texte_popup_OH(this.OH_geom)  ## POPUP\n      \n      leafletProxy(\"map\") %>%\n        setView(lat=this.y, lng=this.x, zoom = 18) %>%\n        addPolygons(data=this.OH_geom,\n                    stroke = TRUE,\n                    color= \"black\",\n                    opacity= 0.7,\n                    weight= 5,\n                    fill = FALSE,\n                    group=\"selection\",\n                    popup=this.popup)\n    }\n      \n      else if (st_geometry_type(OH_geom[OH_geom$OH_NUM == choix_OH,])==\"MULTILINESTRING\") {\n        \n        this.OH_geom <- OH_geom[OH_geom$OH_NUM == choix_OH,] %>% st_cast(\"MULTILINESTRING\")\n        # this.OH_ponctuel <- subset(OH_ponctuels_subset$tab, OH_NUM ==  choix_OH)\n        this.coords <- st_bbox(this.OH_geom)\n        this.x <-  this.coords[[1]]\n        this.y <- this.coords[[2]]\n        this.popup <- texte_popup_OH(this.OH_geom)  ## POPUP\n        \n        \n        leafletProxy(\"map\") %>%\n          setView(lat=this.y, lng=this.x, zoom = 18) %>%\n          addPolylines(data=this.OH_geom,\n                       weight=4,\n                       color=\"black\",\n                       group=\"selection\",\n                       popup=this.popup)\n      }\n      \n      else if (st_geometry_type(OH_geom[OH_geom$OH_NUM == choix_OH,])==\"POINT\") {\n        \n        this.OH_geom <- OH_geom[OH_geom$OH_NUM == choix_OH,] %>% st_cast(\"POINT\")\n        \n        this.coords <- st_bbox(this.OH_geom)\n        this.x <-  this.coords[[1]]\n        this.y <- this.coords[[2]]\n        this.popup <- texte_popup_OH(this.OH_geom)  ## POPUP\n        \n        leafletProxy(\"map\") %>%\n          setView(lat=this.y, lng=this.x, zoom = 18) %>%\n          addCircles(data=this.OH_geom,\n                     radius=10,\n                     stroke = TRUE,\n                     color= \"black\",\n                     opacity= 0.7,\n                     weight= 5,\n                     fill = FALSE,\n                     group=\"selection\",\n                     popup=this.popup)\n      }}\n    \n    else  {updateTextInput(session, \"selec_OH\", value = \"Pas d'OH correspondant\")}\n    \n    \n  })\n  \n  #suppression selection\n  observeEvent(\n    input$selec_OH_reset, {\n      leafletProxy(\"map\") %>%\n        clearGroup(\"selection\")\n    })\n  \n  \n  \n  ###########################################################################\n  ##################### ONGLET 2 : AFC & CAH ##############################\n  ###########################################################################\n  \n  #----------------------------------- #2.1.déclaration reactive objects----\n  tab_contingence <- reactiveValues(tab=NULL)\n  reacAFC <- reactiveValues(data=NULL, #resultat du dudi.coa\n                            periodes = NULL, #découpage par période\n                            variables = NULL, #variables fonctionnelle utilisée\n                            tab_biplot = NULL, #tableau pour le biplot\n                            dist_mat = NULL #matrice de distance khi-2 entre les lignes\n                            \n  )\n  reacCAH <- reactiveValues(data=NULL)\n  ranges <- reactiveValues(x = NULL, y = NULL)\n  \n  #----------------------------------- #2.2.INPUT > DONNEES : mise à jour du tableau de contingence & calcul AFC ----\n  observe({\n    nom <- paste(\"tab\",input$select_var,input$select_periodes, sep=\"_\")\n    tab_contingence$tab <- get(nom)\n    \n    # maj nombre de classes pour la CAH (= nombre de lignes)\n    classe_max <- nrow(tab_contingence$tab)\n    updatePickerInput(session,\"nombre_classes\",\n                      choices = seq(1,classe_max,1),\n                      selected=\"4\")\n    \n    AFC <-dudi.coa(tab_contingence$tab, scannf=FALSE, nf=6)\n    reacAFC$data <- AFC\n    reacAFC$periodes <- input$select_periodes\n    reacAFC$variables <- input$select_var\n    reacAFC$dist_mat <- dist.dudi(AFC)\n    \n    \n  })\n  \n  #----------------------------------- #2.3.INPUT > OUTPUT ----\n  \n  #---- tableau de contingence----\n  observe({\n    output$tab_contingence <-renderDataTable(\n      tab_contingence$tab,\n      options=list(pageLength = 10, scrollX=TRUE, searching=FALSE)\n    )\n  })\n  \n  #---- tableau variance des axes & choix des axes à ploter ----\n  observe({\n    \n    AFC <- reacAFC$data\n    \n    inertie_AFC <- summary.variance.dudi(AFC)\n    \n    #plot variance axes\n    output$plot_inertie_axes <- renderPlot(\n      barplot.dudi.variance(data=AFC, \n                            sumdata=inertie_AFC,\n                            titre=NULL))\n  })    \n  \n  observe({ \n    AFC <- reacAFC$data\n    #update de l'UI pour choix des axes à ploter\n    updatePickerInput(session,\"axe1\",\n                      choices = seq(1,AFC$nf,1),\n                      selected=\"1\")\n    updatePickerInput(session,\"axe2\",\n                      choices = seq(1,AFC$nf,1),\n                      selected=\"2\")\n  })\n  \n  #---- AFC : BIPLOT et TAB  contribution ----\n  observe({\n    \n    req(input$axe1, input$axe2)\n    AFC <- reacAFC$data\n    \n    #tableau pour biplot\n    biplot_col <- setNames(AFC$co, names(AFC$li))\n    biplot_col$type_var <- input$select_var\n    biplot_col$taille <- 35\n    biplot_li <- AFC$li\n    biplot_li$type_var <- input$select_periodes\n    biplot_li$taille <- 100\n    biplot_li$color_var <- \"périodes\"\n    biplot_li$nom_var <- \"périodes\"\n    \n    \n    #actualisation palettes, titre et liste_variable selon variables\n    if (reacAFC$variables==\"urb\"){\n      biplot_col$color_var <- str_sub(row.names(biplot_col), start=-1)\n      liste_var <- sort(unique(as.character(OH_geom$V_URB_NOM)))\n      biplot_col$nom_var <- liste_var\n      palette_biplot <- couleurs_vurb\n      names(palette_biplot) <- liste_var\n      biplot_titre<- paste(\"Analyse factorielle des correspondances : valeurs urbaines * périodes de \", reacAFC$periodes, \" ans\", sep=\"\")\n    }\n    else if (reacAFC$variables==\"portee\"){\n      biplot_col$color_var <- str_sub(row.names(biplot_col), start=-1)\n      liste_var <- sort(unique(as.character(OH_geom$PORTEE_NOM)))\n      biplot_col$nom_var <- liste_var\n      palette_biplot<- couleurs_portees\n      names(palette_biplot) <- liste_var\n      biplot_titre <- paste(\"Analyse factorielle des correspondances : portées * périodes de \", reacAFC$periodes, \" ans\", sep=\"\")\n    }\n    else if (reacAFC$variables==\"usage\"){\n      # browser()\n      biplot_col$color_var <- str_sub(row.names(biplot_col), start=-2, end=-2)\n      #ajout d'une colonne nom valeur urb = V_URB_NOM\n      biplot_col$nom_var <- cut (biplot_col$color_var %>% as.numeric(),\n                                 breaks=c(0,2,3,4,5,6,7),\n                                 labels=c(\"1.voirie, aménagement\",\n                                          \"2.structures défensives et militaires\",\n                                          \"3.constructions civiles\",\n                                          \"4.édifices religieux\",\n                                          \"5.lieux d'inhumation\",\n                                          \"6.lieux de commerce, artisanat, production\"),\n                                 right=FALSE,\n                                 include.lowest = TRUE)\n      palette_biplot <- couleurs_vurb\n      liste_var <- sort(unique(as.character(OH_geom$V_URB_NOM)))\n      names(palette_biplot) <- liste_var\n      biplot_titre <- paste(\"Analyse factorielle des correspondances : valeurs d'usage * périodes de \", reacAFC$periodes,\" ans\", sep=\"\")\n    }\n    \n    \n    if(input$masquer_biplot==\"aucune\"){tab_biplot <- rbind(biplot_li, biplot_col)}\n    else if (input$masquer_biplot==\"périodes\"){tab_biplot <-biplot_col}\n    else if (input$masquer_biplot==\"caractéristiques fonctionnelles\"){tab_biplot <-biplot_li}\n    \n    #axes\n    axe1 <- as.numeric(input$axe1)\n    axe2 <- as.numeric(input$axe2)\n    \n    #variance expliquée \n    pctvar_A1 <- round(AFC$eig[axe1]*100/sum(AFC$eig))\n    pctvar_A2 <- round(AFC$eig[axe2]*100/sum(AFC$eig))\n    titre_axe1 <- paste(\"Axe n°\", axe1, \" (\",pctvar_A1, \"% de variance expliquée)\", sep=\"\")\n    titre_axe2 <- paste(\"Axe n°\", axe2, \" (\",pctvar_A2, \"% de variance expliquée)\", sep=\"\")\n    \n    \n    #BIPLOT\n    biplot <- \n      scatterD3(x=tab_biplot[,axe1], y=tab_biplot[,axe2],\n                lab=row.names(tab_biplot),\n                col_var = tab_biplot$nom_var,\n                colors=c(\"périodes\"=\"grey\", palette_biplot),\n                point_opacity = 0.8,\n                hover_opacity = 1,\n                hover_size = 2,\n                xlab=titre_axe1,\n                ylab=titre_axe2,\n                symbol_lab=\"variables en lignes et colonnes\",\n                col_lab=\"type de variable\",\n                transitions = FALSE,\n                fixed=TRUE,\n                caption =list(title=biplot_titre,\n                              subtitle =\"L. Nahassia, Géographie-cité, 2018 | Sources : ToToPI, LAT, CITERES\")\n                \n      )\n    \n    output$plot_biplot <- renderScatterD3(biplot)\n    \n    \n    # CONTRIBUTIONS\n    contrib_AFC <- inertia.dudi(AFC, row.inertia = TRUE, col.inertia = TRUE)\n    \n    output$contrib_periodes <-renderDataTable(\n      contrib_AFC$row.abs,\n      options=list(pageLength = 10, scrollX=TRUE, searching=FALSE)\n    )\n    \n    output$contrib_variables <-renderDataTable(\n      contrib_AFC$col.abs,\n      options=list(pageLength = 10, scrollX=TRUE, searching=FALSE)\n    )\n    \n    \n  }) # fin observe BIPLOT AFC\n  \n  #---- CAH : dendrogramme, inertie ----\n  observe({\n    \n    CAH <- hclust(\n      reacAFC$dist_mat,\n      method= input$methode,\n      members=apply(tab_contingence$tab, MARGIN=1, FUN=sum)\n    )\n    reacCAH$data <- CAH\n    \n    #dendrogramme\n    output$plot_dendro <- renderPlot(\n      \n      ggdendrogram2(CAH)+\n        labs(\n          title=\"Dendrogramme de la CAH\",\n          caption=\"L. Nahassia, Géographie-cités, 2018 | Sources : ToToPI, LAT, CITERES\",\n          x=NULL,\n          y=NULL)+\n        theme_fivethirtyeight()+\n        theme_ln()+\n        theme(\n          axis.text=element_text(angle = 90, size=8.5, hjust=1, vjust=0.5),\n          panel.grid.major.x=element_blank(),\n          panel.border = element_blank())\n      \n    )\n    \n    #inertie découpage\n    inertie_CAH <- sort(CAH$height, decreasing = TRUE)\n    inertie_CAH <- inertie_CAH/sum(inertie_CAH)*100\n    #gestion longueur graphique\n    if (length(inertie_CAH)>40) {\n      nb_coupes <- 40\n      tab <- inertie_CAH[1:40]\n      soustitre <- \"pour les 40 premiers noeuds du dendrogramme\"} \n    else {\n      nb_coupes <-length(inertie_CAH)\n      tab <- inertie_CAH\n      soustitre <- \"pour tous les noeuds du dendrogramme\"} \n    \n    #plot inertie\n    \n    output$plot_in_cah <- renderPlot(\n      \n      ggplot()+\n        geom_bar(\n          aes(x=c(1:nb_coupes),y=tab),\n          stat=\"identity\",\n          fill=\"#DD4B39\",\n          alpha=0.7)+\n        labs(\n          title=\"Part de l'inertie des différentes coupes de la CAH\",\n          subtitle= soustitre,\n          caption=\"L. Nahassia, Géographie-cités, 2018 | Sources : ToToPI, LAT, CITERES\",\n          x=\"nombre de classes\",\n          y=\"Part de l'inertie totale (%)\")+\n        scale_x_continuous(breaks=c(1:length(tab)), expand=c(0.01, 0.01))+\n        theme_fivethirtyeight()+\n        theme_ln()\n    )\n    \n  })#fin observe dendrogramme\n  \n  #---- CAH caractérisation des classes ----\n  \n  observe({\n    \n    req(input$nombre_classes)\n    \n    nombre_classes <- input$nombre_classes\n    flip <- classes.periodes.cah(CAH=reacCAH$data, nb=nombre_classes)\n    classes_periodes <- flip$entier\n    dates_axe <- flip$axe\n    \n    #frise chronologique avec classes\n    output$frise_classes <- renderPlot(\n      \n      ggplot(classes_periodes) +\n        geom_segment(aes(x=deb, xend=fin, y=0., yend=0., color=classes) , linetype=1, size=6) +\n        scale_color_manual(values=palette_CAH(nombre_classes))+\n        scale_x_continuous(breaks=c(dates_axe$deb,2016))+\n        labs(colour=\"classes de la CAH\")+\n        theme_bw() + \n        theme(panel.grid.minor = element_blank(), \n              panel.grid.major =  element_blank(),\n              panel.border = element_blank(),\n              text = element_text(colour=\"grey40\"),\n              axis.text.x = element_text(size=11, angle=90, vjust =0.6, hjust=1, colour=\"grey40\"),\n              axis.title.x=element_blank(),\n              axis.title.y=element_blank(),\n              axis.text.y=element_blank(),  \n              axis.ticks.y=element_blank(),\n              aspect.ratio =0.02,\n              legend.position=\"top\",\n              legend.direction = \"horizontal\",\n              legend.title= element_text(size=12)\n        )+\n        guides(colour=guide_legend(nrow=1))\n      \n    )\n    \n    # graphiques des caractéristiques des classes\n    \n    #choix tableau de contigence avec périodes mais comptage pour le moment vurbaine -> à faire au choix après ?\n    nom <- paste(\"tab_urb\",input$select_periodes, sep=\"_\")\n    tab_car <- get(nom)\n\n    #tab indépendance mis en forme pour plot\n    tab_ind <- indep.classes.cah(tab_cont = tab_car, CAH = reacCAH$data, nb=nombre_classes %>% as.numeric()) %>% \n      gather(key=Fonction, value=\"data\", v_urb.1 : v_urb.6)\n    \n    output$plot_classes <- renderPlot(\n      \n      ggplot() +\n        geom_bar(aes(x=reorder(Fonction,data), y=data, fill=Cluster), stat= \"identity\")+\n        scale_fill_manual(values=palette_CAH(nombre_classes))+\n        facet_wrap(~Cluster)+\n        coord_flip()+\n        labs(\n          x = \"Moyenne des écarts standardisés par classe (résidus de Pearson)\",\n          y=\"Valeurs urbaines\",\n          title= \"Caractérisation des périodes urbaines par type de fonctions\",\n          subtitle=\"Classe de périodes: CAH (distance khi2)\",\n          caption=\"L. Nahassia, Géographie-cités, 2018 | Sources : ToToPI, LAT, CITERES\")+\n        theme_fivethirtyeight()+\n        theme_ln()\n      \n    )\n    \n    \n  })\n  \n  \n  \n}) # fin du serveur\n\n\n",
    "created" : 1529865320735.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2618657474",
    "id" : "ADD4D15F",
    "lastKnownWriteTime" : 1531689156,
    "last_content_update" : 1531689156228,
    "path" : "D:/Sync/1recherche/1these/SIG/VISU/shiny/explOH_12/server.r",
    "project_path" : "server.r",
    "properties" : {
        "docOutlineSize" : "240",
        "docOutlineVisible" : "1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}