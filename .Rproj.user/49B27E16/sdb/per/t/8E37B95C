{
    "collab_server" : "",
    "contents" : "################################\n# Shiny app pour afficher les objets selon le temps avec leaflet\n# juin 2017\n# Server pour explOH_8\n################################\n\n#####\nlibrary(shiny)\n\n\n\n\nshinyServer(function(input, output, session) {\n  \n  #1. carte de base\n  output$map <- renderLeaflet({\n    leaflet() %>%\n      setView(lat=47.394211, lng=0.687247, zoom = 15) %>%\n      \n      ##tiles\n      addProviderTiles(\"CartoDB.Positron\", group=\"clair\") %>%\n      # addProviderTiles(\"Esri.WorldImagery\", group = \"satellite\") %>%\n      \n      ##layer control\n      addLayersControl(\n        baseGroups = c(\"clair\", \"satellite\"),\n        overlayGroups = c(\"géometries\", \"ensembles urbains\", \"traits de rive\"),\n        options=layersControlOptions(autoZIndex=TRUE)\n      ) %>%\n      hideGroup(c(\"traits de rive\",\"ensembles urbains\")) %>% \n      \n      addLegend(position=\"bottomlef\", title = legende$title_legend, pal = legende$pal_legend, values = legende$val_legend, opacity = 1)\n    \n    \n  })\n  \n  \n  #2. Declaration des reactive objects\n  \n  #OH à supprimer, ajouter, et tableau en memoire (au début toutes dates toutes valeurs urbaines)\n  OH_subset <- reactiveValues(\n    OH_A = OH_geom,\n    OH_B = NULL,\n    ID_del=NULL,\n    ID_add = NULL,\n    tab_add = OH_geom\n  )\n  \n  #contexte\n  ens_urb_subset <- reactiveValues(tab = ens_urb)\n  traits_rive_subset <- reactiveValues(tab = traits_rive)\n  #couleurs\n  legende <- reactiveValues(\n    alpha_polygones = NA,\n    pal_couleurs= NA,\n    pal_legend = NA,\n    val_legend = NA,\n    title_legend = NA)\n  \n  observe({\n    # updateTextInput(session,\"test\", value=nrow(OH_subset$tab))\n    \n  })\n  \n  #3. INPUT > INPUT : Mise à jour slider temps selon autres éléments (graphes et élements textes)\n  \n  # observe({\n  #   req(input$ohfreq_brush$xmin,input$ohfreq_brush$xmax)\n  #   updateSliderInput(session = session,\n  #                     inputId = \"limites\",\n  #                     # value=c(subset_limites_temps$date_min,subset_limites_temps$date_max)\n  #                     value=c(input$ohfreq_brush$xmin,input$ohfreq_brush$xmax)\n  #   )\n  # })\n  \n  #date de départ pour lancer l'appli\n  req(date_random)\n  updateSliderInput(session = session,\n                    inputId = \"limites\",\n                    value=c(min(date_random),max(date_random)))\n  \n  observeEvent(input$selec_bornes_temps, {\n    req(input$borne_temps_1, input$borne_temps_2)\n    updateSliderInput(session = session,\n                      inputId = \"limites\",\n                      # value=c(subset_limites_temps$date_min,subset_limites_temps$date_max)\n                      value=c(input$borne_temps_1,input$borne_temps_2))\n  })\n  \n  #4. INPUT > DONNEES : sélection des subset en fonction des INPUTS\n  \n  ##contextes (temps)\n  observe({\n    # req(max(input$limites), min(input$limites))\n    ens_urb_subset$tab <- ens_urb %>% filter (date_debut<=max(input$limites) & date_fin>=min(input$limites))\n    traits_rive_subset$tab <- traits_rive %>% filter (DEBUT<=max(input$limites) & FIN>=min(input$limites))\n    \n  })\n  \n  ##Objets Historiques (temps, fonctions)\n  observe({\n    req(max(input$limites), min(input$limites), input$choix_fonctions)\n    #subset avec choix actuels\n    OH_subset$OH_B <- OH_geom %>% \n      filter(DATE_DEB<=max(input$limites)) %>% \n      filter(DATE_FIN>=min(input$limites)) %>% \n      filter(V_URB %in% c(input$choix_fonctions[1:6]))\n    #comparaison des ID du subset actuel et du subset précédent\n    OH_subset$ID_del <- setdiff(OH_subset$OH_A$OH_NUM, OH_subset$OH_B$OH_NUM) #ID des Shape à supprimer\n    OH_subset$ID_add <- setdiff(OH_subset$OH_B$OH_NUM, OH_subset$OH_A$OH_NUM)\n    #subset des OH à ajouter\n    OH_subset$tab_add <- OH_geom %>% filter(OH_NUM %in% OH_subset$ID_add)\n    updateTextInput(session,\"test\", value=length(OH_subset$ID_add))\n    #subset actuel mis en mémoire\n    OH_subset$OH_A <- OH_subset$OH_B\n  })\n  \n  \n  #5. INPUT > OUTPUT\n  \n  #VALEURS LEGENDE SELON CHOIX\n  \n  observe ({\n    if (input$couleur_OH == \"v_urb\") # afficher selon valeurs urbaines\n    {\n      legende$alpha_polygones <- 0.7\n      legende$pal_couleurs <- palette_fonctions\n      legende$pal_legend <- palette_fonctions\n      legende$val_legend <- OH_geom$V_URB_NOM\n      legende$title_legend <- \"Valeurs urbaines des OH\"\n    }\n    \n    else if (input$couleur_OH == \"portee\") # afficher selon portée\n    { legende$alpha_polygones <- 0.9\n    legende$pal_couleurs <- palette_portees\n    legende$pal_legend <- palette_portees\n    legende$val_legend <- OH_geom$PORTEE\n    legende$title_legend <- \"Niveau de portée des OH\"}\n    \n    else if (input$couleur_OH == \"duree\") # afficher selon durée d'existence REVOIR CETTE LEGENDE\n      #couleurs calculées sur le même intervalle (le plus global == OHgeom) sinon cela devrait donner une légende différente pour chaque type de geom\n    { legende$alpha_polygones <- 0.8\n    legende$pal_couleurs <- ramp_duree\n    legende$pal_legend <- ramp_duree\n    legende$val_legend <- (OH_geom$DATE_FIN - OH_geom$DATE_DEB)\n    legende$title_legend <- \"Durée d'existence des OH\"}\n    \n  })\n  \n  #MAP OUTPUT\n  observe ({\n    #pbm avec tableau tab_add\n    OH_pt <- OH_subset$OH_B[st_geometry_type(OH_subset$OH_B)==\"POINT\",] %>% st_cast(\"POINT\") #cast pour éviter les erreurs de class non comprises par leaflet\n    OH_pg <- OH_subset$tab_add[st_geometry_type(OH_subset$tab_add)==\"MULTIPOLYGON\",] %>% st_cast(\"MULTIPOLYGON\")\n    OH_pl <- OH_subset$tab_add[st_geometry_type(OH_subset$tab_add)==\"MULTILINESTRING\",] %>% st_cast(\"MULTILINESTRING\")\n    \n    ## POPUP\n    popup_ens_urb <- texte_popup_ens_urb(ens_urb_subset$tab)\n    popup_traits_rive <- texte_popup_traits_rive(traits_rive_subset$tab)\n    popup_pg <-texte_popup_OH(OH_pg)\n    popup_pl <-texte_popup_OH(OH_pl)\n    popup_pt <-texte_popup_OH(OH_pt)\n    \n    ## CARTE\n    leafletProxy(\"map\") %>%\n      # clearMarkers() %>%\n      clearGroup(group=c(\"ensembles urbains\", \"traits de rive\")) %>% \n      addPolygons(data=ens_urb_subset$tab,\n                  group=\"ensembles urbains\",\n                  color=\"black\",\n                  fill=FALSE,\n                  weight=2,\n                  popup=popup_ens_urb) %>%\n      addPolylines(data=traits_rive_subset$tab,\n                   group=\"traits de rive\",\n                   color=\"blue\",#pointillés ?\n                   dashArray =\"5,5\",\n                   fillOpacity = 0.9,\n                   weight=3,\n                   popup=popup_traits_rive) %>%\n      #OH\n      addPolygons(data=OH_pg,\n                  stroke = TRUE,\n                  weight=1,\n                  opacity=legende$alpha_polygones,\n                  color=~legende$pal_couleurs(OH_pg$V_URB_NOM),\n                  group=\"géometries\",\n                  layerId= as.character(OH_pg$OH_NUM),\n                  popup=popup_pg) %>%\n      addCircles(data=OH_pt,\n                radius=10,\n                color=~legende$pal_couleurs(OH_pt$V_URB_NOM),\n                stroke = FALSE,\n                fillOpacity = 0.7,\n                group=\"géometries\",\n                layerId= as.character(OH_pt$OH_NUM),\n                 popup=popup_pt) %>%\n      addPolylines(data=OH_pl,\n                   weight=1,\n                   color=~legende$pal_couleurs(OH_pl$V_URB_NOM),\n                   opacity= 0.7,\n                   group=\"géometries\",                  \n                   layerId= as.character(OH_pl$OH_NUM),\n                   popup = popup_pl) %>%\n      removeShape(layerId=as.character(OH_subset$ID_del))\n    #possible d'ajouter className pour css\n    #possible d'ajouter un ID pour suppprimer + spécifiquement cette légende\n    \n    \n  })\n  \n  #CHANGEMENT DE LEGENDE (fixe par type de représentation)\n  observe ({\n    leafletProxy(\"map\") %>%\n      clearControls() %>% \n      addLegend(position=\"bottomlef\", title = legende$title_legend, pal = legende$pal_legend, values = legende$val_legend, opacity = 1)\n    \n  })\n  \n  \n  #6. INTERACTIONS AUTRES\n  \n  # mise en valeur de l'OH sélectionnée, même si elle est hors de ce qui est affiché\n  observeEvent(input$selec_OH, {\n    \n    #*******\n    #A FAIRE\n    #catch si pas numéro > ifelse sur typeof de la variable ?\n    # voir si zoom sur bouding box (pbm avec les points et les petits polygones)\n    #*******\n    \n    ## selection selon le type de géométrie\n    leafletProxy(\"map\") %>% clearGroup(\"selection\")\n    choix_OH <- input$num_OH\n    \n    if (nrow(OH_geom[OH_geom$OH_NUM == choix_OH,])<1)\n    { updateTextInput(session, \"num_OH\", value = \"aucun OH correspondant\") }\n    \n    else if (st_geometry_type(OH_geom[OH_geom$OH_NUM == choix_OH,])==\"MULTIPOLYGON\") {\n\n      this.OH_geom <- OH_geom[OH_geom$OH_NUM == choix_OH,] %>% st_cast(\"MULTIPOLYGON\")\n      # this.OH_ponctuel <- subset(OH_ponctuels_subset$tab, OH_NUM ==  choix_OH)\n      this.coords <- st_bbox(this.OH_geom)\n      this.x <-  this.coords[[1]]\n      this.y <- this.coords[[2]]\n      this.popup <- texte_popup_OH(this.OH_geom)  ## POPUP\n      \n      leafletProxy(\"map\") %>%\n        setView(lat=this.y, lng=this.x, zoom = 18) %>%\n        addPolygons(data=this.OH_geom,\n                    stroke = TRUE,\n                    color= \"black\",\n                    opacity= 0.7,\n                    weight= 5,\n                    fill = FALSE,\n                    group=\"selection\",\n                    popup=this.popup)\n      }\n    \n    else if (st_geometry_type(OH_geom[OH_geom$OH_NUM == choix_OH,])==\"MULTILINESTRING\") {\n      \n      this.OH_geom <- OH_geom[OH_geom$OH_NUM == choix_OH,] %>% st_cast(\"MULTILINESTRING\")\n      # this.OH_ponctuel <- subset(OH_ponctuels_subset$tab, OH_NUM ==  choix_OH)\n      this.coords <- st_bbox(this.OH_geom)\n      this.x <-  this.coords[[1]]\n      this.y <- this.coords[[2]]\n      this.popup <- texte_popup_OH(this.OH_geom)  ## POPUP\n      \n      \n      leafletProxy(\"map\") %>%\n        setView(lat=this.y, lng=this.x, zoom = 18) %>%\n        addPolylines(data=this.OH_geom,\n                     weight=4,\n                     color=\"black\",\n                     group=\"selection\",\n                     popup=this.popup)\n    }\n    \n    else if (st_geometry_type(OH_geom[OH_geom$OH_NUM == choix_OH,])==\"POINT\") {\n      \n      this.OH_geom <- OH_geom[OH_geom$OH_NUM == choix_OH,] %>% st_cast(\"POINT\")\n      \n      this.coords <- st_bbox(this.OH_geom)\n      this.x <-  this.coords[[1]]\n      this.y <- this.coords[[2]]\n      this.popup <- texte_popup_OH(this.OH_geom)  ## POPUP\n      \n      leafletProxy(\"map\") %>%\n        setView(lat=this.y, lng=this.x, zoom = 18) %>%\n        addCircles(data=this.OH_geom,\n                   radius=10,\n                   stroke = TRUE,\n                   color= \"black\",\n                   opacity= 0.7,\n                   weight= 5,\n                   fill = FALSE,\n                   group=\"selection\",\n                   popup=this.popup)\n    }\n    \n    \n    \n  })\n  \n  #suppression selection\n  observeEvent(input$deselec_OH, {leafletProxy(\"map\") %>% clearGroup(\"selection\")})\n  \n})\n\n\n",
    "created" : 1494091435052.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "15|31|34|2|\n92|11|97|2|\n122|12|147|2|\n",
    "hash" : "3188130524",
    "id" : "8E37B95C",
    "lastKnownWriteTime" : 1500895511,
    "last_content_update" : 1500895511686,
    "path" : "D:/Sync/1recherche/1these/SIG/VISU/shiny/explOH_8/server.r",
    "project_path" : "server.r",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}