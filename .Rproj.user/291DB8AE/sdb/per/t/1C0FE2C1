{
    "contents" : "################################\n# Shiny app pour afficher les objets selon le temps avec leaflet\n# Octobre 2016\n# Server pour shiny_3_2geom\n################################\n\n##### \nlibrary(shiny)\n\n\nshinyServer(function(input, output, session) {\n  \n  # outputOptions(output, \"ohfreq\", priority = 0)\n  # options(shiny.trace=TRUE)\n  \n  ### ELEMENT GENERAUX\n  \n  #palettes >> dans global R si ne s'adaptent pas (cf durées)\n  palette_fonctions <- colorFactor(palette, unique(OH_ponctuels_4326@data$V_URB))\n  #palette_portee <- A FAIRE\n  ramp_duree <- colorNumeric(c(\"#ffa500\",\"red\"), domain = OH_ponctuels_4326@data$OH_FIN - OH_ponctuels_4326@data$OH_DEB)\n  #previewColors(colorFactor(brewer.pal(6,\"Set1\"), domain = NULL),unique(OH_ponctuels_4326@data$V_URB))\n  #il y avait plus de niveaux dans v_urb que dans palette donc interpolation et couleurs moches\n  #previewColors(colorRamp(c(\"#fee0d2\",\"#a50f15\")), OH_ponctuels_4326@data$DATE_FIN)\n  \n  \n  ### OUTPUT DE BASE\n  \n  #----POPUPS : contenu ----\n  pop_ponctuels <- popup_text(OH_ponctuels_4326)\n  pop_ens_urb <- popup_ens_urb(ens_urb)\n  \n  #----affichage carte avec données de base----\n  ## A FAIRE : ne pas mettre les points ici, que les éléments qui ne bougeront pas ?\n  output$map <- renderLeaflet({\n    leaflet(OH_ponctuels_4326) %>%\n      setView(lat=47.396248, lng=0.686614, zoom = 14) %>% \n      \n      ##tiles\n      addProviderTiles(\"CartoDB.Positron\", group=\"clair\") %>% \n      addProviderTiles(\"CartoDB.DarkMatter\", group=\"sombre\") %>% \n      addProviderTiles(\"Esri.WorldImagery\", group = \"satellite\") %>%\n      \n      ##data\n      addCircles(data=OH_ponctuels_4326, \n                group=\"points\",\n                radius=10, \n                color=\"#ffa500\", \n                stroke = FALSE,\n                fillOpacity = 0.7,\n                popup=pop_ponctuels) %>% # voir si on peut pas faire qqchose de mieux rapport au niveau de zoom\n      \n      addPolygons(data=ens_urb,\n                  group=\"ensembles urb\",\n                  color=\"black\",\n                  fill=FALSE,\n                  weight=2,\n                  popup=pop_ens_urb) %>% \n      \n      addPolylines(data=traits_rive,\n                   group=\"rive\",\n                   color=\"blue\",\n                   weight=3 #pointillés ?\n      ) %>% \n      \n      ##layer control\n      addLayersControl(\n        baseGroups = c(\"clair\",\"sombre\",\"satellite\"),\n        overlayGroups = c(\"points\", \"ensembles urb\") #pbm : ordre des calques dépend de l'ordre du clic pour l'affichage\n      ) %>% \n      \n      hideGroup(c(\"ensembles urb\",\"rive\"))\n    \n    \n  })\n  \n  \n  ### REACTIVE OBJECTS\n  \n  #reactive object pour stocker les subset de données\n  OH_ponctuels_sub <- reactiveValues (tab = OH_ponctuels_4326)\n  ens_urb_sub <- reactiveValues(tab = ens_urb)\n  traits_rive_sub <- reactiveValues(tab = traits_rive)\n  \n  #   #reactive object pour stocker les dates min et max\n  #   subset_limites_temps <- reactiveValues(date_min = NULL, date_max=NULL)\n  \n  \n  ### OUTPUT MISES A JOUR\n  \n  #   #est-ce nécessaire ? Voir quand ça va se complexifier... > mettre un if else dans ce premier observe\n  #   observe({\n  #     # req(input$limites)\n  #     subset_limites_temps$date_min <-min(input$limites)\n  #     subset_limites_temps$date_max <-max(input$limites)\n  #   })\n  \n  #     observe({\n  #       req(input$ohfreq_brush)\n  #       subset_limites_temps$date_max <- input$ohfreq_brush$xmax\n  #       subset_limites_temps$date_min <- input$ohfreq_brush$xmin\n  #       runjs(\"document.getElementById('p1_brush').remove()\")\n  #       runjs(\"document.getElementById('p2_brush').remove()\")\n  #     })\n  \n  #mise à jour des dates mins et max sur le slider en fonction des autres graphes\n  observe({\n    req(input$ohfreq_brush$xmin,input$ohfreq_brush$xmax)\n    updateSliderInput(session = session,\n                      inputId = \"limites\",\n                      # value=c(subset_limites_temps$date_min,subset_limites_temps$date_max)\n                      value=c(input$ohfreq_brush$xmin,input$ohfreq_brush$xmax)\n    )\n  })\n  \n  #sélection des ensembles urbains et des rives en fonction des inputs temporels\n  observe({\n    req(max(input$limites),min(input$limites))\n    ens_urb_sub$tab <- subset(ens_urb, DEBUT<=max(input$limites) & FIN>=min(input$limites))\n    \n  })\n  \n  observe({\n    req(max(input$limites),min(input$limites))\n    traits_rive_sub$tab <- subset(traits_rive, DEBUT<=max(input$limites) & FIN>=min(input$limites))\n    \n  })\n  \n  ## sélection des OH, mise en forme des options, et affichage de la carte en fonction des inputs de l'utilisateurs ----\n  \n  #---- sous-ensemble des OH selon sélection temporelle et fonctionnelle -----\n  observe({\n    req(max(input$limites), min(input$limites), input$choix_fonctions)\n    ##subset temps\n    OH_ponctuels_sub_t <- subset(OH_ponctuels_4326, DATE_DEB<=max(input$limites) & DATE_FIN>=min(input$limites))\n    ##subset fonctions\n    usage_range <- c(eval(parse(text= input$choix_fonctions[1])),\n                     eval(parse(text= input$choix_fonctions[2])),\n                     eval(parse(text= input$choix_fonctions[3])),\n                     eval(parse(text= input$choix_fonctions[4])),\n                     eval(parse(text= input$choix_fonctions[5])),\n                     eval(parse(text= input$choix_fonctions[6])))\n    \n    OH_ponctuels_sub$tab <- subset(OH_ponctuels_sub_t, V_USAGE %in% usage_range)\n  })\n  \n  \n  #---- Actualisation de la carte selon les choix ----\n  observe ({\n    \n    # conditions couleurs et légende (si besoin pour autre chose que la carte > les sortir)\n    if (input$couleur_OH == \"v_urb\") # afficher selon valeurs urbaines\n    {my_col_ponctuels <- ~palette_fonctions(OH_ponctuels_sub$tab@data$V_URB)\n    pal_legend <- palette_fonctions\n    val_legend <- OH_ponctuels_sub$tab@data$V_URB_NOM\n    title_legend <- \"Valeurs urbaines des OH\"}\n    \n    #     else if (input$color_OH == \"portee\") # afficher selon portée\n    #     {my_col_ponctuels <- ~palette_fonction(V_URB)}\n    \n    else if (input$couleur_OH == \"duree\") # afficher selon durée d'existence\n    {my_col_ponctuels <- ~ramp_duree(OH_ponctuels_sub$tab@data$DATE_FIN - OH_ponctuels_sub$tab@data$DATE_DEB)\n    pal_legend <- ramp_duree\n    val_legend <- (OH_ponctuels_sub$tab@data$DATE_FIN - OH_ponctuels_sub$tab@data$DATE_DEB)\n    title_legend <- \"Durée d'existence des OH\"}\n    \n    else #pas de choix\n    {my_col_ponctuels <-\"#ffa500\" }\n    \n    \n    ## ACTUALISATION POPUP ET CARTE\n    \n    ## popup \n    pop_ponctuels_sub <-popup_text(OH_ponctuels_sub$tab)\n    pop_ens_urb <- popup_ens_urb(ens_urb_sub$tab)\n    \n    ## carte\n    leafletProxy(\"map\") %>%\n      clearShapes() %>% \n      clearMarkers() %>% \n      clearControls() %>% \n      addCircles(data=OH_ponctuels_sub$tab, \n                group=\"points\", \n                radius=10, \n                color=my_col_ponctuels, \n                stroke = FALSE, \n                fillOpacity = 0.9,\n                popup=pop_ponctuels_sub)  %>% \n      addLegend(position=\"bottomlef\", title = title_legend, pal = pal_legend, values = val_legend, opacity = 1) %>% \n      addPolygons(data=ens_urb_sub$tab,\n                  group=\"ensembles urb\",\n                  color=\"black\",\n                  fill=FALSE,\n                  weight=2,\n                  popup=pop_ens_urb) %>% \n      addPolylines(data=traits_rive_sub$tab,\n                   group=\"rive\",\n                   color=\"blue\",#pointillés ?\n                   weight=3)\n    #possible d'ajouter className pour css\n    #possible d'ajouter un ID pour suppprimer + spécifiquement cette légende\n  }, priority = 10)\n  \n  #---- Graphe de répartition des objets dans le temps entre date min et date max ----\n  # Avec surlignage de la sélection temporelle\n  vals <- reactiveValues(pdata=ggplot())\n  #creation du graphe\n  observe({\n    date_min <- min(input$limites)\n    date_max <- max(input$limites)\n    echelle <- input$plot_echelle_y\n    \n    subset_m_fonction_an <- subset(m_fonction_an, m_fonction_an$annee<=date_max & m_fonction_an$annee>=date_min)\n    \n    # output$ohfreq <- renderPlot({\n    p <- ggplot()+\n      geom_bar(data = m_fonction_an, \n               aes(x=annee, y=value),\n               stat=\"identity\", \n               width=1,\n               fill=\"#CDD2D4\") +\n      geom_bar(data = subset_m_fonction_an, \n               aes(x=annee, y=value, fill=variable),\n               stat = \"identity\",\n               width=1)+\n      scale_fill_manual(values=adjustcolor(palette, alpha.f=0.8))+\n      ggtitle(\"Nombre d'OH par année et par valeur urbaine\")+\n      xlab(\"année\")+\n      ylab(\"Nombre d'OH\")+\n      theme_hc()+\n      theme_facettes_clair()+\n      facet_wrap(~ v_urb, scales=echelle, nrow=2)\n    \n    vals$data <- p\n    #     }, \n    #     bg=\"transparent\")\n  }, priority = 0)\n  \n  #affichage\n      observeEvent(vals$data,{\n        output$ohfreq <- renderPlot({isolate(vals$data)}, bg=\"transparent\")\n      })#tout aussi long\n  #   \n  \n  #---- Afficher ou non les ensembles urbains avec légende---\n  observeEvent(input$afficher_ens_urb, {\n    if (input$afficher_ens_urb == FALSE){\n      leafletProxy(\"map\") %>% \n        hideGroup(\"ensembles urb\")\n      \n      \n    } else {\n      leafletProxy(\"map\") %>%showGroup(\"ensembles urb\")\n    }\n  })\n  \n  #---- Afficher ou non les traits de rive ---\n  observeEvent(input$afficher_traits_rive, {\n    if (input$afficher_traits_rive == FALSE){\n      leafletProxy(\"map\") %>% hideGroup(\"rive\")\n    } else {\n      leafletProxy(\"map\") %>%showGroup(\"rive\")\n    }\n  })\n  \n  #---- mise en valeur de l'OH sélectionné ----\n  observeEvent(input$selec_OH, {\n    \n    #*******\n    #A FAIRE \n    #catch si pas numéro > ifelse sur typeof de la variable\n    # voir si zoom sur bouding box (pbm avec les points et les petits polygones)\n    #*******\n    \n    # updateTextInput(session, \"resultat\", value = nrow(subset(OH_geom_pt_sub@data, OH_NUM == choix_OH)))\n    leafletProxy(\"map\") %>% clearGroup(\"selection\")\n    choix_OH <- as.numeric(input$num_OH)\n    \n    if (nrow(subset(OH_ponctuels_sub$tab@data, OH_NUM == choix_OH))>0) {\n      \n      this.OH <- subset(OH_ponctuels_sub$tab, OH_NUM ==  choix_OH)\n      this.coords <- coordinates(this.OH)\n      this.x <-  this.coords[1]\n      this.y <- this.coords[2]\n      \n      leafletProxy(\"map\") %>%\n        setView(lat=this.y, lng=this.x, zoom = 19) %>% \n        addCircles(data=this.OH,\n                   radius=10, \n                   color=\"#f1eea7\", \n                   stroke = \"#e9e576\", \n                   fillOpacity = 1, \n                   group=\"selection\",\n                   popup=pop_ponctuels) \n      \n      updateTextInput(session, \"resultat\", value = \"point\")\n      \n    } else {updateTextInput(session, \"num_OH\", value = \"aucun OH correspondant\")}\n    \n    \n  })\n  \n  #---- suppression selection ----\n  observeEvent(input$deselec_OH, {leafletProxy(\"map\") %>% clearGroup(\"selection\")})\n  \n  #leaflet  \n  \n  ## Affichage du graph de fréquences SANS CHIHI\n  #   output$ohfreq <- renderPlot({\n  #     \n  #     date_min <- min(input$limites)\n  #     date_max <- max(input$limites)\n  #     echelle <- input$plot_echelle_y\n  #     \n  #     subset_m_fonction_an <- subset(m_fonction_an, m_fonction_an$annee<=date_max & m_fonction_an$annee>=date_min)\n  #     ggplot(data = subset_m_fonction_an, aes(x=annee, y=value, fill=variable))+\n  #       geom_bar(data = m_fonction_an, \n  #                aes(x=annee, y=value),\n  #                stat=\"identity\", \n  #                width=1,\n  #                fill=\"#CDD2D4\") +\n  #       geom_bar(stat = \"identity\",\n  #                width=1)+\n  #       scale_fill_manual(values=adjustcolor(palette, alpha=0.8))+\n  #       ggtitle(\"Nombre d'OH par année et par valeur urbaine\")+\n  #       xlab(\"année\")+\n  #       ylab(\"Nombre d'OH\")+\n  #       theme_hc()+\n  #       theme_facettes_clair()+\n  #       facet_wrap(~ v_urb, scales=echelle, nrow=2)\n  #     \n  #   }, \n  #   bg=\"transparent\", priority =0)\n  \n  \n  #   outputOptions(output, \"ohfreq\", priority = 0)\n  outputOptions(output, \"map\", priority = 10)\n  \n})\n\n\n",
    "created" : 1481029918611.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1220468081",
    "id" : "1C0FE2C1",
    "lastKnownWriteTime" : 1481184797,
    "path" : "C:/Users/lue/Sync/1recherche/1these/SIG/VISU/visu_temps/shiny_3_2geom/server.r",
    "project_path" : "server.r",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}